# send_email.py

import smtplib
import imaplib
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.text import MIMEText
import os
import html2text
import email
import sqlite3
import logging
import time  # Make sure to import time

def send_email_smtp(db_file, email_account_id, to_email, subject, html_content, attachment_paths):
    # Configure logging
    logger = logging.getLogger('send_email')
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    
    # File handler for logging
    fh = logging.FileHandler('send_email.log')
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    
    # Stream handler for console output
    ch = logging.StreamHandler()
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    
    # Connect to the database to retrieve email account settings
    conn = sqlite3.connect(db_file)
    cursor = conn.cursor()
    
    # Fetch the email account details
    cursor.execute('''
        SELECT "from_email", "username", "password", "smtp_host", "smtp_port", "imap_host", "imap_port", "ssl"
        FROM email_accounts
        WHERE "ID" = ?
    ''', (email_account_id,))
    result = cursor.fetchone()
    conn.close()
    
    if not result:
        logger.error(f"No email account found with ID {email_account_id}")
        return False
    
    from_email, username, password, smtp_host, smtp_port, imap_host, imap_port, ssl = result
    
    msg = MIMEMultipart('mixed')
    msg['From'] = from_email
    msg['To'] = to_email
    msg['Subject'] = subject
    
    # Create a plain text version of the HTML content
    plain_text_content = html2text.html2text(html_content)
    
    # Attach the plain text and HTML content
    alternative_part = MIMEMultipart('alternative')
    alternative_part.attach(MIMEText(plain_text_content, 'plain'))
    alternative_part.attach(MIMEText(html_content, 'html'))
    msg.attach(alternative_part)
    
    # Attach files
    for path in attachment_paths:
        with open(path, 'rb') as f:
            part = MIMEApplication(f.read(), Name=os.path.basename(path))
        part['Content-Disposition'] = f'attachment; filename="{os.path.basename(path)}"'
        msg.attach(part)
    
    # Send the email using SMTP
    try:
        logger.info(f"Connecting to SMTP server {smtp_host}:{smtp_port}")
        if ssl:
            server = smtplib.SMTP_SSL(smtp_host, smtp_port)
        else:
            server = smtplib.SMTP(smtp_host, smtp_port)
            server.starttls()
        server.login(username, password)
        server.sendmail(from_email, to_email, msg.as_string())
        server.quit()
        logger.info(f"Email sent to {to_email} from {from_email}")
    except Exception as e:
        logger.exception(f"Failed to send email to {to_email}: {e}")
        return False
    
    # Save the sent email to the 'Sent' folder via IMAP
    try:
        logger.info(f"Connecting to IMAP server {imap_host}:{imap_port}")
        if ssl:
            imap = imaplib.IMAP4_SSL(imap_host, imap_port)
        else:
            imap = imaplib.IMAP4(imap_host, imap_port)
        imap.login(username, password)
        folder_name = '"[Gmail]/Sent Mail"' if 'gmail' in imap_host.lower() else 'Sent'
        imap.select(folder_name)
        
        # Append the sent message to the Sent folder
        imap.append(folder_name, '\\Seen', imaplib.Time2Internaldate(time.time()), msg.as_bytes())
        imap.logout()
        logger.info("Email saved to Sent folder")
    except Exception as e:
        logger.exception(f"Failed to save email to Sent folder: {e}")
        # Even if saving fails, we consider the email as sent
        pass
    
    return True
